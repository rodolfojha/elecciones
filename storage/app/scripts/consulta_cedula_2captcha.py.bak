#!/usr/bin/env python3
"""
Script para consultar el censo electoral usando 2Captcha para resolver CAPTCHAs
Adaptado para funcionar como servicio persistente que mantiene el navegador abierto
"""

import os
import sys
import time
import json
import requests
import threading
from datetime import datetime
from pathlib import Path
from queue import Queue
from concurrent.futures import ThreadPoolExecutor

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from webdriver_manager.chrome import ChromeDriverManager

# ============================================================
# CONFIGURACI√ìN
# ============================================================

TWOCAPTCHA_API_KEY = "717ce26f1b3537da97312bab40f9ddad"
URL_CONSULTA = "https://wsp.registraduria.gov.co/censo/consultar/"
PERFIL_CHROME = os.path.join(os.path.dirname(os.path.abspath(__file__)), "chrome_perfil_2captcha")

# Directorios para comunicaci√≥n
BASE_DIR = Path(__file__).parent
REQUEST_DIR = BASE_DIR / "requests"
RESPONSE_DIR = BASE_DIR / "responses"

# Crear directorios si no existen
REQUEST_DIR.mkdir(exist_ok=True)
RESPONSE_DIR.mkdir(exist_ok=True)

# ============================================================

class TwoCaptchaSolver:
    """Resuelve CAPTCHAs usando el servicio 2Captcha"""
    
    API_URL_IN = "http://2captcha.com/in.php"
    API_URL_RES = "http://2captcha.com/res.php"
    
    def __init__(self, api_key):
        self.api_key = api_key
    
    def get_balance(self):
        """Obtiene el balance de la cuenta"""
        try:
            response = requests.get(
                self.API_URL_RES,
                params={
                    "key": self.api_key,
                    "action": "getbalance",
                    "json": 1
                },
                timeout=30
            )
            result = response.json()
            if result.get("status") == 1:
                return float(result.get("request", 0))
            return None
        except Exception as e:
            print(f"Error obteniendo balance: {e}", file=sys.stderr)
            return None
    
    def solve_recaptcha_v2(self, site_key, page_url):
        """Resuelve reCAPTCHA v2 usando 2Captcha"""
        print(f"\nüì§ Enviando reCAPTCHA a 2Captcha...", file=sys.stderr)
        
        # Paso 1: Enviar el CAPTCHA
        try:
            response = requests.post(
                self.API_URL_IN, 
                data={
                    "key": self.api_key,
                    "method": "userrecaptcha",
                    "googlekey": site_key,
                    "pageurl": page_url,
                    "json": 1
                },
                timeout=30
            )
            
            result = response.json()
            
            if result.get("status") != 1:
                error = result.get('request', 'Unknown error')
                print(f"‚úó Error: {error}", file=sys.stderr)
                return None
            
            captcha_id = result.get("request")
            print(f"‚úì CAPTCHA enviado. ID: {captcha_id}", file=sys.stderr)
            
        except Exception as e:
            print(f"‚úó Error de conexi√≥n: {e}", file=sys.stderr)
            return None
        
        # Paso 2: Esperar y obtener la soluci√≥n
        print(f"‚è≥ Esperando soluci√≥n de 2Captcha...", file=sys.stderr)
        
        for i in range(40):  # M√°ximo ~3.5 minutos
            time.sleep(5)
            
            try:
                response = requests.get(
                    self.API_URL_RES, 
                    params={
                        "key": self.api_key,
                        "action": "get",
                        "id": captcha_id,
                        "json": 1
                    },
                    timeout=30
                )
                
                result = response.json()
                status = result.get("status")
                request_val = result.get("request", "")
                
                if status == 1:
                    token = request_val
                    print(f"‚úì ¬°CAPTCHA RESUELTO! (~{(i+1)*5} segundos)", file=sys.stderr)
                    return token
                elif request_val == "CAPCHA_NOT_READY":
                    if (i + 1) % 4 == 0:
                        print(f"   ‚è≥ Procesando... ({(i+1)*5}s)", file=sys.stderr)
                else:
                    print(f"‚úó Error: {request_val}", file=sys.stderr)
                    return None
                    
            except Exception as e:
                print(f"   Error: {e}", file=sys.stderr)
        
        print("‚úó Tiempo de espera agotado", file=sys.stderr)
        return None

class ConsultaCenso:
    """Consulta el censo electoral usando 2Captcha"""
    
    def __init__(self, api_key):
        self.driver = None
        self.captcha_solver = TwoCaptchaSolver(api_key)
        self.navegador_iniciado = False
        
    def iniciar_navegador(self, headless=True):
        """Inicia el navegador Chrome (solo una vez)"""
        if self.navegador_iniciado and self.driver:
            print("‚úì Navegador ya est√° iniciado", file=sys.stderr)
            return
        
        chrome_options = Options()
        
        if headless:
            chrome_options.add_argument("--headless=new")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--window-size=1920,1080")
            chrome_options.add_argument("--disable-extensions")
            chrome_options.add_argument("--blink-settings=imagesEnabled=false")
            chrome_options.add_argument("--disable-plugins")
            chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
        else:
            chrome_options.add_argument(f"--user-data-dir={PERFIL_CHROME}")
            chrome_options.add_argument("--profile-directory=Default")
            chrome_options.add_argument("--start-maximized")
        
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        
        prefs = {
            "profile.default_content_setting_values": {
                "images": 2,
                "plugins": 2,
            }
        }
        chrome_options.add_experimental_option("prefs", prefs)
        
        service = Service(ChromeDriverManager().install())
        self.driver = webdriver.Chrome(service=service, options=chrome_options)
        
        if headless:
            self.driver.set_page_load_timeout(20)
            self.driver.implicitly_wait(5)
        
        self.driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
            "source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"
        })
        
        self.navegador_iniciado = True
        print("‚úì Navegador iniciado", file=sys.stderr)
        
    def obtener_site_key(self):
        """Obtiene el site key del reCAPTCHA"""
        try:
            recaptcha = self.driver.find_element(By.CLASS_NAME, "g-recaptcha")
            site_key = recaptcha.get_attribute("data-sitekey")
            return site_key
        except:
            try:
                iframe = self.driver.find_element(By.CSS_SELECTOR, "iframe[src*='recaptcha']")
                src = iframe.get_attribute("src")
                if "k=" in src:
                    site_key = src.split("k=")[1].split("&")[0]
                    return site_key
            except:
                pass
            
            # Buscar en el HTML
            page_source = self.driver.page_source
            if "data-sitekey" in page_source:
                import re
                match = re.search(r'data-sitekey="([^"]+)"', page_source)
                if match:
                    return match.group(1)
        return None
        
    def inyectar_token(self, token):
        """Inyecta el token del CAPTCHA resuelto"""
        result = self.driver.execute_script(f"""
            var token = '{token}';
            var textareas = document.querySelectorAll('textarea[name="g-recaptcha-response"]');
            textareas.forEach(function(ta) {{
                ta.innerHTML = token;
                ta.value = token;
            }});
            var byId = document.getElementById('g-recaptcha-response');
            if (byId) {{
                byId.innerHTML = token;
                byId.value = token;
            }}
            var widget = document.querySelector('.g-recaptcha');
            if (widget) {{
                var callback = widget.getAttribute('data-callback');
                if (callback && typeof window[callback] === 'function') {{
                    window[callback](token);
                }}
            }}
            return true;
        """)
        return result
        
    def consultar_documento(self, numero_documento):
        """Consulta un documento (reutiliza el navegador abierto)"""
        try:
            print(f"üîç Consultando: {numero_documento}", file=sys.stderr)
            
            # Cargar p√°gina
            self.driver.get(URL_CONSULTA)
            time.sleep(2)
            
            wait = WebDriverWait(self.driver, 20)
            
            # Buscar campo de documento
            campo = None
            try:
                campo = wait.until(EC.presence_of_element_located((By.ID, "nuip")))
            except:
                try:
                    campo = wait.until(EC.presence_of_element_located((By.NAME, "nuip")))
                except:
                    try:
                        campo = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "input#nuip, input[name='nuip']")))
                    except:
                        return None
            
            # Ingresar documento
            campo.clear()
            time.sleep(0.5)
            campo.send_keys(numero_documento)
            
            # Obtener site key
            site_key = self.obtener_site_key()
            if not site_key:
                return None
            
            # Resolver CAPTCHA
            token = self.captcha_solver.solve_recaptcha_v2(site_key, URL_CONSULTA)
            if not token:
                return None
            
            # Inyectar token
            self.inyectar_token(token)
            time.sleep(1)
            
            # Clic en consultar
            try:
                boton = wait.until(EC.element_to_be_clickable((By.ID, "enviar")))
                boton.click()
            except:
                self.driver.execute_script("""
                    var boton = document.getElementById('enviar');
                    if (boton) {
                        boton.click();
                    } else {
                        document.querySelector('input[type="submit"]').click();
                    }
                """)
            
            time.sleep(3)
            
            # Extraer resultados
            return self._extraer_resultados()
                
        except Exception as e:
            print(f"‚úó Error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            return None
    
    def _extraer_resultados(self):
        """Extrae los datos de la tabla"""
        try:
            wait = WebDriverWait(self.driver, 10)
            tabla = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "table")))
            
            filas = tabla.find_elements(By.TAG_NAME, "tr")
            
            for fila in filas[1:]:
                celdas = fila.find_elements(By.TAG_NAME, "td")
                
                if len(celdas) >= 6:
                    resultado = {
                        'NUIP': celdas[0].text.strip(),
                        'DEPARTAMENTO': celdas[1].text.strip(),
                        'MUNICIPIO': celdas[2].text.strip(),
                        'PUESTO': celdas[3].text.strip(),
                        'DIRECCION': celdas[4].text.strip(),
                        'MESA': celdas[5].text.strip(),
                        'FECHA_CONSULTA': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    return resultado
            
            return None
            
        except Exception as e:
            print(f"‚ö† Error extrayendo: {e}", file=sys.stderr)
            return None
    
    def cerrar(self):
        """Cierra navegador"""
        if self.driver:
            self.driver.quit()
            self.navegador_iniciado = False

def procesar_consulta_worker(request_file, api_key):
    """Procesa una consulta individual en un thread separado con su propio navegador"""
    consulta = None
    try:
        with open(request_file, 'r', encoding='utf-8') as f:
            request_data = json.load(f)
        
        cedula = request_data.get('cedula')
        request_id = request_data.get('id')
        
        if not cedula or not request_id:
            return
        
        # Crear una nueva instancia de consulta con su propio navegador
        consulta = ConsultaCenso(api_key)
        consulta.iniciar_navegador(headless=True)
        
        print(f"üîç [Thread] Consultando: {cedula}", file=sys.stderr)
        
        # Realizar consulta
        resultado = consulta.consultar_documento(cedula)
        
        # Preparar respuesta
        if resultado:
            response = {
                'success': True,
                'message': 'Informaci√≥n encontrada',
                'data': {
                    'cedula': resultado.get('NUIP', cedula),
                    'departamento': resultado.get('DEPARTAMENTO'),
                    'municipio': resultado.get('MUNICIPIO'),
                    'puesto_votacion': resultado.get('PUESTO'),
                    'direccion_puesto': resultado.get('DIRECCION'),
                    'mesa': resultado.get('MESA'),
                    'fecha_consulta': resultado.get('FECHA_CONSULTA')
                }
            }
        else:
            response = {
                'success': False,
                'message': 'No se encontr√≥ informaci√≥n para esta c√©dula',
                'data': None
            }
        
        # Guardar respuesta
        response_file = RESPONSE_DIR / f"{request_id}.json"
        with open(response_file, 'w', encoding='utf-8') as f:
            json.dump(response, f, ensure_ascii=False, indent=2)
        
        # Eliminar request procesado
        os.remove(request_file)
        
        print(f"‚úì [Thread] Consulta {cedula} completada", file=sys.stderr)
        
    except Exception as e:
        print(f"‚úó [Thread] Error procesando consulta: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
    finally:
        # Cerrar el navegador de este thread
        if consulta:
            consulta.cerrar()

def main():
    """Funci√≥n principal - servicio persistente con soporte para consultas concurrentes"""
    print("üöÄ Iniciando servicio de consulta de c√©dulas (modo concurrente)...", file=sys.stderr)
    
    # Verificar API Key
    if not TWOCAPTCHA_API_KEY or TWOCAPTCHA_API_KEY == "TU_API_KEY_DE_2CAPTCHA":
        print("‚ö† CONFIGURA TU API KEY DE 2CAPTCHA", file=sys.stderr)
        sys.exit(1)
    
    # Verificar balance
    solver = TwoCaptchaSolver(TWOCAPTCHA_API_KEY)
    balance = solver.get_balance()
    
    if balance is not None:
        print(f"üí∞ Balance 2Captcha: ${balance:.4f}", file=sys.stderr)
        if balance < 0.01:
            print("‚ö† Balance muy bajo", file=sys.stderr)
    
    # N√∫mero m√°ximo de consultas concurrentes
    MAX_WORKERS = 5  # Puedes ajustar este n√∫mero seg√∫n tus necesidades
    
    # ThreadPoolExecutor para manejar m√∫ltiples consultas simult√°neamente
    executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)
    processed_files = set()  # Para evitar procesar el mismo archivo dos veces
    
    try:
        print(f"‚úì Servicio listo. M√°ximo {MAX_WORKERS} consultas concurrentes.", file=sys.stderr)
        print("‚úì Esperando consultas...", file=sys.stderr)
        
        while True:
            # Buscar archivos de request
            request_files = list(REQUEST_DIR.glob("*.json"))
            
            for request_file in request_files:
                # Evitar procesar el mismo archivo dos veces
                file_id = str(request_file)
                if file_id not in processed_files:
                    processed_files.add(file_id)
                    
                    # Enviar a procesar en un thread separado
                    executor.submit(procesar_consulta_worker, request_file, TWOCAPTCHA_API_KEY)
            
            # Limpiar archivos procesados de la lista despu√©s de un tiempo
            # (para evitar que la lista crezca indefinidamente)
            if len(processed_files) > 100:
                # Mantener solo los √∫ltimos 50
                processed_files = set(list(processed_files)[-50:])
            
            time.sleep(0.5)  # Esperar 0.5 segundos entre checks (m√°s r√°pido)
            
    except KeyboardInterrupt:
        print("\nüëã Cerrando servicio...", file=sys.stderr)
        executor.shutdown(wait=True)
    except Exception as e:
        print(f"‚úó Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        executor.shutdown(wait=True)

if __name__ == "__main__":
    main()


